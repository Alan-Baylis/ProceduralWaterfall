#pragma kernel Init
#pragma kernel Emit
#pragma kernel Update
#pragma kernel Move

#include "UnityCG.cginc"
#include "ClassicNoise2D.cginc"

#define NUM_THREAD_X 8
#define NUM_THREAD_Y 1
#define NUM_THREAD_Z 1

cbuffer CB
{
	int _StreamsCount;
	int _PerlinT;
	float _Gravity;
	float _DeltaTime;
	float _Jet;
	float _RandSeed;
}

struct Drop
{
	uint streamId;
	float dropSize;
	float3 position;
	float3 velocity;
};

struct StreamLine
{
	int id;
	float3 birthPosition;
	float3 deathPosition;
	float3 position;
	float3 initVelocity;
	float3 velocity;
};

float rand(float2 co)
{
	return frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453);
}

RWStructuredBuffer<Drop> _DropsBuff;
RWStructuredBuffer<StreamLine> _StreamLinesBuffer;

// Dead
AppendStructuredBuffer<Drop> _DeadBuff1_In;
ConsumeStructuredBuffer<Drop> _DeadBuff1_Out;

// Alive 1 / 2
AppendStructuredBuffer<Drop> _AliveBuff1_In;
ConsumeStructuredBuffer<Drop> _AliveBuff1_Out;
AppendStructuredBuffer<Drop> _AliveBuff2_In;
ConsumeStructuredBuffer<Drop> _AliveBuff2_Out;

Texture2D _PerlinTexture;

// 0 Init

[numthreads(NUM_THREAD_X, NUM_THREAD_Y, NUM_THREAD_Z)]
void Init(uint3 DTid : SV_DispatchThreadID)
{
	_DeadBuff1_In.Append(_DropsBuff[DTid.x]);
}

// 1 Emit

[numthreads(NUM_THREAD_X, NUM_THREAD_Y, NUM_THREAD_Z)]
void Emit(uint3 DTid : SV_DispatchThreadID)
{

	// Velocity
	float theta = cnoise(float2(DTid.x, _RandSeed)) * radians(45);
	float3 v = _StreamLinesBuffer[DTid.x].initVelocity;
	float absV = length(v.xz);

	// Position
	float4 perlin = _PerlinTexture[uint2(DTid.x, _PerlinT)];
	float emitAmount = perlin.x * 8 * 16;
	float3 p = _StreamLinesBuffer[DTid.x].birthPosition;
	int nextStreamId = clamp(DTid.x + 1, 0, _StreamsCount - 1);
	float3 posGap = _StreamLinesBuffer[nextStreamId].birthPosition - p;
	float diff = 2.0 * (1.0 - perlin.x) * rand(float2(_RandSeed, DTid.x));

	for (int i = 0; i < emitAmount; i++)
	{
		Drop d = _DeadBuff1_Out.Consume();
		d.streamId = DTid.x;

		d.dropSize = 0.1f;

		d.velocity = float3(v.x + 1.0 * absV * sin(theta),
			                v.y - 1.0 * v.y * rand(float2(DTid.x, i + 3)),
			                v.z - 1.0 * absV * cos(theta));

		d.position = float3(p.x + posGap.x * rand(float2(DTid.x, i + 1)) + diff * d.velocity.x,
			                p.y + 0.3 * perlin.x,
			                p.z + posGap.z * rand(float2(DTid.x, i + 2)) + diff * d.velocity.z);

		_AliveBuff2_In.Append(d);
	}
}

// 2 Update

[numthreads(NUM_THREAD_X, NUM_THREAD_Y, NUM_THREAD_Z)]
void Update(uint3 DTid : SV_DispatchThreadID)
{
	Drop d = _AliveBuff1_Out.Consume();

	d.velocity.y += -_Gravity * _DeltaTime * _Jet;

	float3 p = d.position;
	float3 v = d.velocity;
	d.position = float3(p.x + v.x * 0.01 * (1.0 + rand(float2(DTid.x, _RandSeed))) * _DeltaTime,
		                p.y + v.y * _DeltaTime,
		                p.z + v.z * 0.02 * (1.0 + rand(float2(DTid.x, _RandSeed + 2)) * _DeltaTime));

	float3 deathPos = _StreamLinesBuffer[d.streamId].deathPosition;

	if (d.position.y < deathPos.y) {
		_DeadBuff1_In.Append(d);
	} else {
		_AliveBuff2_In.Append(d);
	}
}

// 3
[numthreads(NUM_THREAD_X, NUM_THREAD_Y, NUM_THREAD_Z)]
void Move(uint3 DTid : SV_DispatchThreadID)
{
	Drop d = _AliveBuff2_Out.Consume();
	_AliveBuff1_In.Append(d);
}